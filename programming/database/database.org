#+SETUPFILE: ../../styles/readtheorg.setup
#+TITLE: Database

* SQL
** =DISTINCT=

#+CAPTION: 示例
#+begin_src sql
SELECT COUNT(DISTINCT city) FROM address;
#+end_src

#+CAPTION: =SELECT= 多列时， =DISTINCT= 作用于所有列的整合结果
#+begin_src sql
# | a |  b  |
# |---+-----|
# | 1 | foo |
# | 1 | bar |
# | 2 | foo |
# | 2 | foo |

SELECT DISTINCT a, b FROM test;
# | 1 | foo |
# | 1 | bar |
# | 2 | foo |
#+end_src

** =HAVING=

=WHERE= 不能用于聚合函数， =HAVING= 可以聚合函数的条件。

#+CAPTION: 示例：查询租住的公寓多于一间的房客
#+begin_src sql
SELECT tenant_id
FROM tenant_apartment
GROUP BY tenant_id
HAVING COUNT(*) > 1;
#+end_src

** =JOIN=

file:../images/database/01.jpg

| Implicit join        | 等同于 =INNER JOIN= |
|----------------------+---------------------|
| =(INNER) JOIN=       |                     |
|----------------------+---------------------|
| =LEFT (OUTER) JOIN=  |                     |
|----------------------+---------------------|
| =RIGHT (OUTER) JOIN= |                     |
|----------------------+---------------------|
| =FULL OUTER JOIN=    |                     |

* 索引

- 对表中一列或多列的值进行排序的一种数据结构。
- 可以加快查找、排序的速度。
- 但需要更多的存储空间，插入、修改数据时要花费更多的时间。

#+ATTR_HTML: :class no-border
| *唯一索引*       |   |
|------------------+---|
| *主键索引*       |   |
|------------------+---|
| *（非）聚集索引* |   |
|------------------+---|
| *多列索引*       |   | 

#+ATTR_HTML: :class no-border
| *适合创建索引的列*   | 主键（强调唯一性）。             |
|                      | 外键（加快连接表速度）。         |
|                      | 经常用于 =WHERE= 条件的列。      |
|                      | 经常根据范围进行搜索的列。       |
|                      | 经常排序的列。                   |
|----------------------+----------------------------------|
| *不适合创建索引的列* | 修改性能的要求大于检索性能的列。 |

** 聚集

#+ATTR_HTML: :class no-border
| *聚集索引*   | Clustered index                                                                      |
|              | 索引中键值的逻辑顺序与数据的物理存储顺序一致，因此每个表只有唯一的聚集索引。         |
|              | 如按照拼音查字，由于字典正文本身就是按照拼音顺序排列的，因此不需要再去查其他目录。   |
|              | 叶子结点即存储真实的数据行，不再有另外单独的数据页。                                 |
|              | 能够迅速缩小查询范围，避免全表扫描。                             |
|--------------+--------------------------------------------------------------------------------------|
| *非聚集索引* | Non-clustered index                                                                  |
|              | 如按照部首查字，偏旁部首的目录与正文的顺序不相关，需要先查到页码，再去找正文的位置。 |
|              | 叶子结点包含索引字段值及指向数据页数据行的逻辑指针。                                 |

#+CAPTION: 使用场景
|                  | *聚集索引* | *非聚集索引* |
|------------------+------------+--------------|
| 主键列           | Y          | Y            |
|------------------+------------+--------------|
| 外键列           | Y          | Y            |
|------------------+------------+--------------|
| 一个或极少不同值 |            |              |
|------------------+------------+--------------|
| 小数目的不同值   | Y          |              |
|------------------+------------+--------------|
| 大数目的不同值   |            | Y            |
|------------------+------------+--------------|
| 查找条件为范围   | Y          |              |
|------------------+------------+--------------|
| 分组排序         | Y          | Y            |
|------------------+------------+--------------|
| 频繁更新的列     |            | Y            |
|------------------+------------+--------------|
| 频繁修改索引的列 |            | Y            |

* 事务

#+ATTR_HTML: :class no-border
| *Atomicity*   | 一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。 |
|---------------+------------------------------------------------------------------------------|
| *Consistency* | 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。                     |
|---------------+------------------------------------------------------------------------------|
| *Isolation*   | 防止多个事务并发执行时，由于交叉执行而导致数据的不一致。                     |
|---------------+------------------------------------------------------------------------------|
| *Durability*  | 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。             |

* 优化
** Denormalization

#+ATTR_HTML: :class no-border
| *Normalization*   | 减少冗余                         |
|                   | =JOIN= 查询耗时较多              |
|-------------------+----------------------------------|
| *Denormalization* | 减少 =JOIN= 查询耗时             |
|                   | =INSERT= 和 =UPDATE= 耗时较多    |
|                   | 数据冗余，可能存在不一致         |
|                   | 占用更多存储空间                 |
|                   | 常用于需要扩展（scalable）的系统 |

** Sharding
* NoSQL

#+ATTR_HTML: :class no-border
| *关系型数据库* | 保证数据的一致性，读写操作都是事务的（ACID），适合于对一致性有要求的系统，如银行系统。 |
|                | 维护数据一致性的代价是读写性能比较差。                                                 |
|                | 有固定的表结构，扩展性差，不能应付数据结构的巨大改动。                                 |
|                | 适合海量数据的持久化存储。                                                             |
|----------------+----------------------------------------------------------------------------------------|
| *NoSQL 数据库* | 没有固定的表结构。                                                                     |
|                | 严格上不是一种数据库，而是一种数据结构化存储方法的集合。                               |
|----------------+----------------------------------------------------------------------------------------|
| *SNS 的特点*   | 对数据的一致性要求不高（用户看到的内容更新不一致，或者差几秒，是可以容忍的）。         |
|                | 对数据库的并发读写能力要求高。                                                         |
|                | 大型应用的升级、功能增加，经常需要数据结构的巨大改动。                                 |

* Quote

#+BEGIN_QUOTE
The key challenge in data modeling is balancing the needs of the application, the performance characteristics of the database engine, and the data retrieval patterns. When designing data models, always consider the application usage of the data (i.e. queries, updates, and processing of the data) as well as the inherent structure of the data itself. [[https://docs.mongodb.com/v3.0/core/data-modeling-introduction/][(source)]]
#+END_QUOTE
